'''This module implements specialized function providing sequence analysis or 
data predealing to the whole program

* find_10_35_pos  Find the -10 and -35 start location of one sequence
* find_10_35_pos_listseq    Find the -10 and -35 start location of sequence groups
* get_kmer_stat   Get the normalize frequency of generative sequence groups and 
                          control sequence groups of each k-mer
* kmer_count      Count k-mer of a sequence groups
* remove_1035     Return a list of separated sequence exclude -10 and -35 region
'''

import collections

def find_10_35_pos(seq):
    '''
    Find the -10 and -35 start location of one sequence

    Parameters
    ----------
    seq : string
        one sequence string
        -10 and -35 sequences would be 'TCGA'
        other regions would be 'M'
        for example, an input sequence would be:
            'MMMMMMMMMTAGACAMMMMMMMMTATAATMMMMM'
            
    Returns
    -------
    pos_10: start position of -10 motif
    pos_35: start position of -35 motif
    '''
    
    pos_10 = 0
    pos_35 = 0
    flag = 0
    for i in range(len(seq)):
        if seq[i] != 'M' and flag == 0:
            pos_35 = i
            flag = 1
        elif flag == 1 and seq[i] == 'M':
            flag = 2
        elif flag == 2 and seq[i] != 'M':
            pos_10 = i
            flag = 3
    if flag == 3:
        return pos_10, pos_35
    else:
        return -1, -1

def find_10_35_pos_listseq(sequence_list):
    '''
    Find the -10 and -35 start location of sequence groups

    Parameters
    ----------
    seq : list of string
        one line in a list represent a sequence. 
        -10 and -35 sequences would be 'TCGA'
        other regions would be 'M'
        for example, an input sequence would be:
            'MMMMMMMMMTAGACAMMMMMMMMTATAATMMMMM'
            
    Returns
    -------
    pos_10_list: each item in the list represents start position of -10 motif
    pos_35_list: each item in the list represents start position of -35 motif
    '''
    pos_10_list = []
    pos_35_list = []
    for i in range(len(sequence_list)):
        pos_10, pos_35 = find_10_35_pos(sequence_list[i])
        pos_10_list.append(pos_10)
        pos_35_list.append(pos_35)
    return pos_10_list, pos_35_list


def get_kmer_stat(generative_seq, control_seq, k_size):
    '''
    Get the normalize frequency of generative sequence groups and 
    control sequence groups of each k-mer

    Parameters
    ----------
    generative_seq : list of string
        one line in a list represent a sequence.
        sequences generated by the model
    control_seq : list of string
        one line in a list represent a sequence.
        sequences used as the control groups
    k_size: num
        the k-mer number, it may be 3-mer, 4-mer, 5-mer ...

    Returns
    -------
    kmer_stat_control: The kmer frequency of each kmer in control group
    kmer_stat_gen: The kmer frequency of each kmer in generative sequence group

    '''
    kmer_stat_control, kmer_stat_gen = kmer_count(control_seq, k_size), kmer_count(generative_seq, k_size)
    # Normalize
    total_control = sum(kmer_stat_control.values())
    kmer_stat_control = {k: v / total_control for k, v in kmer_stat_control.items()}
    total_gen = sum(kmer_stat_gen.values())
    kmer_stat_gen = {k: v / total_gen for k, v in kmer_stat_gen.items()}
    # Get the sorted dict
    kmer_stat_control, kmer_stat_gen = collections.OrderedDict(sorted(kmer_stat_control.items())),  collections.OrderedDict(sorted(kmer_stat_gen.items()))
    return kmer_stat_control, kmer_stat_gen


def convert(n, x, lens=4):
    '''
    Parameters
    ----------
    n : int
        the whole index number to represent the sequence kmer, for example
        0: 'AAAA'
        1: 'AAAT'
        2: 'AAAC'
        ...
    x : int
        the number of composition elements, for DNA sequences, x = 4
    lens : int
        the k_size of k-mer. The default is 4.

    Returns
    -------
    res : list
        list of elements to represent the k-mer composition, for example, 
        it will output [3,3,3,3,3,3] when k (lens) equals to 6
    '''
    list_a = [0,1,2,3,4,5,6,7,8,9,'A','b','C','D','E','F']
    list_b = []
    while True:
        s,y = divmod(n,x)
        list_b.append(y)
        if s == 0:
            break
        n = s
    list_b.reverse()
    res = []
    for i in range(lens):
        res.append(0)
    res0 = []
    for i in list_b:
        res0.append(list_a[i])
    for i in range(len(res0)):
        res[lens - i - 1] = res0[len(res0) - i - 1]
    return res


def kmer_count(sequence, k_size):
    '''
    Count k-mer of a sequence groups

    Parameters
    ----------
    sequence : list of string
        one line in a list represent a sequence.
        The input could be:
        ['TTATATATATAGCCTA'] or
        ['TATT', 'GTATTT', 'CCGTAT'], which represent left sequence, medial 
        sequence and right sequences of -10 and -35 regions
    k_size: num
        the k-mer number, it may be 3-mer, 4-mer, 5-mer ...

    Returns
    -------
    kmer_stat: The number of each kmer
    for example, it would be:
        [['AAAA': 8942],
         ['AAAC': 9989],
          ...]
    '''
    bg = ['A', 'T', 'C', 'G']
    kmer_stat = collections.OrderedDict()
    kmer_name = []
    for i in range(4**k_size):
        nameJ = ''
        cov = convert(i, 4,  lens = k_size)
        for j in range(k_size):
            nameJ += bg[cov[j]]
        kmer_name.append(nameJ)
        kmer_stat[nameJ] = 0

    if isinstance(sequence[0], str):
        for i in range(len(sequence)):
            size = len(sequence[i])
            for j in range(len(sequence[i]) - k_size + 1):
                kmer = sequence[i][j: j + k_size]
                try:
                    kmer_stat[kmer] += 1
                except KeyError:
                    kmer_stat[kmer] = 1
    else:
        for i in range(len(sequence)):
            for j in range(len(sequence[i])):
                size = len(sequence[i][j])
                if size > k_size:
                    for k in range(len(sequence[i][j]) - k_size + 1):
                        kmer = sequence[i][j][k : k + k_size]
                        try:
                            kmer_stat[kmer] += 1
                        except KeyError:
                            kmer_stat[kmer] = 1
    return kmer_stat

def remove_1035(sequence, sequence_index):
    '''
    Return a list of separated sequence exclude -10 and -35 region
    for example, when input ACGT(TACAGA)GCTA(TATAAT)TTGA
    the function would return:
    ['ACGT','GCTA','TTGA']

    Parameters
    ----------
    sequence : list of string
        The whole sequence information
    sequence_index: list of string
        The sequence annotation to decide where is -10 and -35 region,
        and other region except -10, -35 would be replaced by 'M'

    Returns
    -------
    flanking_sequence: The sequence groups flanking the -10 and -35 region
    for example, it would be:
        [['ACGT','GCTA','TTGA'],
        ['GGCTT','ATCG','GGTA']]
    which means:
        [left of -35, medium between -10 and -35, right of -10]
    '''
    flanking_sequence = []
    for i in range(len(sequence)):
        sub_flanking = []
        flag = 1
        start = 0
        
        for j in range(len(sequence_index[i])):
            if sequence_index[i][j] != 'M':
                if flag == 1:
                    flag = 0
                    sub_flanking.append(sequence[i][start:j])
            if sequence_index[i][j] == 'M':
                if flag == 0:
                    flag = 1
                    start = j
    
        if sequence_index[i][-1] == 'M':
            sub_flanking.append(sequence[i][start::])

        flanking_sequence.append(sub_flanking)
    return flanking_sequence


def normalize_freq(regions):
    region_total = 0
    region_new = collections.OrderedDict()
    for n_i in regions.keys():
        region_total += regions[n_i]
    for n_i in regions.keys():
        region_new[n_i] = regions[n_i] / region_total
    return region_new